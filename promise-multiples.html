<h5>Promise m√∫ltiples</h5>

<script>

const promise1 = fetch("https://jsonplaceholder.typicode.com/todos/")
.then((resp) => { /*console.log("API1: ", resp);*/ return resp.json();  })
.then((data) => { return data; /*console.log('DataApi1 :>> ', data);*/  })
.catch((error) => new Error("ErrorApi1: ", error));


const promise2 = fetch("https://api.escuelajs.co/api/v1/products")
.then(resp=>resp.json())
.then(data=> { return data; /*console.log('DataApi2 :>> ', data)*/} )
.catch(error => new Error("ErrorApi2: ", error));


const promise3 = fetch("https://pokeapi.co/api/v2/pokemon/pikachu")
.then(resp=>resp.json())
.then(data => { return data; /*console.log("DataApi3:>> ", data)*/ } )
.catch(error => new Error("ErrorApi2: ", error));

// all: se resuelve cuando TODAS se hayan resuelto, o se lanza un error
Promise.all([promise1, promise2, promise3]).then(allData => console.log('ALL: ', allData))

// allSettled: devuelve un array de objetos, y no importa si alguna falla
// status
Promise.allSettled([promise1, promise2, promise3]).then(allData => console.log('ALLSETTLED: ', allData))

// race: devuelve la data de la PRIMERA Promesa que resuelva, pero si falla se devuelve el error
Promise.race([promise1, promise2, promise3]).then(allData => console.log('RACE: ', allData))

// any: si la primera da error, continua con la siguiente que no falle
Promise.any([promise1, promise2, promise3]).then(allData => console.log('ANY: ', allData))

</script>